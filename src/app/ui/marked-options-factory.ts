import { MarkedOptions, MarkedRenderer } from 'ngx-markdown';

/**
 * Parses image sizing syntax from title attribute.
 * The title format is expected to be "width|height" (e.g., "200|150", "200|", "|150")
 * This is generated by preprocessing.
 */
const parseImageDimensionsFromTitle = (
  title: string | null,
): { width?: string; height?: string } => {
  if (!title) {
    return {};
  }

  // Check if title is in our custom format: "width|height"
  const match = title.match(/^(\d*)?\|(\d*)?$/);
  if (!match) {
    return {};
  }

  return {
    width: match[1] && match[1].length > 0 ? match[1] : undefined,
    height: match[2] && match[2].length > 0 ? match[2] : undefined,
  };
};

/**
 * Preprocess markdown to convert image sizing syntax into title attributes.
 * Converts: ![alt](url =WIDTHxHEIGHT) -> ![alt](url "WIDTH|HEIGHT")
 * This allows marked.js to parse it as a valid image with a title.
 */
const preprocessMarkdown = (markdown: string): string => {
  // Match: ![alt](url =WIDTHxHEIGHT) or ![alt](url =WIDTHx) or ![alt](url =xHEIGHT)
  // Capture groups: 1=alt, 2=url, 3=width, 4=height
  return markdown.replace(
    /!\[([^\]]*)\]\(([^\s)]+)\s+=(\d*)x(\d*)\)/g,
    (match, alt, url, width, height) => {
      // Create title attribute with width|height format
      const dimensions = `${width || ''}|${height || ''}`;
      return `![${alt}](${url} "${dimensions}")`;
    },
  );
};

export const markedOptionsFactory = (): MarkedOptions => {
  const renderer = new MarkedRenderer();

  renderer.checkbox = (isChecked: boolean) =>
    `<span class="checkbox material-icons">${isChecked ? 'check_box' : 'check_box_outline_blank'}</span>`;

  renderer.listitem = (text: string) =>
    text.includes('checkbox')
      ? `<li class="checkbox-wrapper ${text.includes('check_box_outline_blank') ? 'undone' : 'done'}">${text}</li>`
      : `<li>${text}</li>`;

  renderer.link = (href, title, text) =>
    `<a target="_blank" href="${href}" title="${title}">${text}</a>`;

  // Custom image renderer with support for sizing syntax
  // Note: indexeddb:// URLs are pre-resolved to blob: URLs before markdown rendering
  // The sizing dimensions are passed via the title attribute in "width|height" format
  renderer.image = (href, title, text) => {
    const { width, height } = parseImageDimensionsFromTitle(title);

    // Build width and height attributes (not style, as Angular sanitizer strips inline styles)
    const widthAttr = width ? ` width="${width}"` : '';
    const heightAttr = height ? ` height="${height}"` : '';

    // Only include title if it's not our custom dimension format
    const isCustomDimensionTitle = title && /^(\d*)?\|(\d*)?$/.test(title);
    const titleAttr = title && !isCustomDimensionTitle ? ` title="${title}"` : '';
    const srcAttr = ` src="${href}"`;

    return `<img alt="${text}"${srcAttr}${titleAttr}${widthAttr}${heightAttr} loading="lazy">`;
  };

  renderer.paragraph = (text) => {
    const split = text.split('\n');
    return split.reduce((acc, p, i) => {
      const result = /h(\d)\./.exec(p);
      if (result !== null) {
        const h = `h${result[1]}`;
        return acc + `<${h}>${p.replace(result[0], '')}</${h}>`;
      }

      if (split.length === 1) {
        return `<p>` + p + `</p>`;
      }

      return acc ? (split.length - 1 === i ? acc + p + `</p>` : acc + p) : `<p>` + p;
    }, '');
  };

  // parse all RFC3986 URIs
  const urlPattern =
    /\b((([A-Za-z][A-Za-z0-9+.-]*):\/\/([^\/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?)\b/gi;

  const rendererTxtOld = renderer.text;
  renderer.text = (text) => {
    return rendererTxtOld(
      text.replace(urlPattern, (url) => {
        return `<a href="${url}" target="_blank">${url}</a>`;
      }),
    );
  };

  const options: MarkedOptions = {
    renderer,
    gfm: true,
    breaks: false,
    pedantic: false,
  };

  // Add preprocessing hook to handle image sizing syntax
  // We need to provide all required hooks functions as stubs
  (options as any).hooks = {
    preprocess: preprocessMarkdown,
    postprocess: (html: string) => html,
    processAllTokens: (tokens: any[]) => tokens,
  };

  return options;
};
