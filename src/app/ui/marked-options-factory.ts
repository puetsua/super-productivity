import { MarkedOptions, MarkedRenderer } from 'ngx-markdown';
import { Hooks } from 'marked';

/**
 * Parses image sizing syntax from title attribute.
 * The title format is expected to be "width|height" (e.g., "200|150", "200|", "|150")
 * This is generated by preprocessing.
 */
const parseImageDimensionsFromTitle = (
  title: string | null,
): { width?: string; height?: string } => {
  if (!title) {
    return {};
  }

  // Check if title is in our custom format: "width|height"
  const match = title.match(/^(\d*)?\|(\d*)?$/);
  if (!match) {
    return {};
  }

  return {
    width: match[1] && match[1].length > 0 ? match[1] : undefined,
    height: match[2] && match[2].length > 0 ? match[2] : undefined,
  };
};

/**
 * Preprocess markdown to convert image sizing syntax into title attributes.
 * Converts: ![alt](url =WIDTHxHEIGHT) -> ![alt](url "WIDTH|HEIGHT")
 * This allows marked.js to parse it as a valid image with a title.
 */
const preprocessMarkdown = (markdown: string): string => {
  // Match: ![alt](url =WIDTHxHEIGHT) or ![alt](url =WIDTHx) or ![alt](url =xHEIGHT)
  // Capture groups: 1=alt, 2=url, 3=width, 4=height
  return markdown.replace(
    /!\[([^\]]*)\]\(([^\s)]+)\s+=(\d*)x(\d*)\)/g,
    (match, alt, url, width, height) => {
      // Create title attribute with width|height format
      const dimensions = `${width || ''}|${height || ''}`;
      return `![${alt}](${url} "${dimensions}")`;
    },
  );
};

export const markedOptionsFactory = (): MarkedOptions => {
  const renderer = new MarkedRenderer();

  renderer.checkbox = ({ checked }) =>
    `<span class="checkbox material-icons">${checked ? 'check_box' : 'check_box_outline_blank'}</span>`;

  renderer.listitem = (item) => {
    // Handle task list items
    if (item.task) {
      const isChecked = item.checked === true;
      const checkboxIcon = isChecked ? 'check_box' : 'check_box_outline_blank';
      return `<li class="checkbox-wrapper ${isChecked ? 'done' : 'undone'}"><span class="checkbox material-icons">${checkboxIcon}</span>${item.text}</li>`;
    }
    return `<li>${item.text}</li>`;
  };

  renderer.link = ({ href, title, text }) =>
    `<a target="_blank" href="${href}" title="${title || ''}">${text}</a>`;

  // Custom image renderer with support for sizing syntax
  // Note: indexeddb:// URLs are pre-resolved to blob: URLs before markdown rendering
  // The sizing dimensions are passed via the title attribute in "width|height" format
  renderer.image = ({ href, title, text }) => {
    const { width, height } = parseImageDimensionsFromTitle(title);

    // Build width and height attributes (not style, as Angular sanitizer strips inline styles)
    const widthAttr = width ? ` width="${width}"` : '';
    const heightAttr = height ? ` height="${height}"` : '';

    // Only include title if it's not our custom dimension format
    const isCustomDimensionTitle = title && /^(\d*)?\|(\d*)?$/.test(title);
    const titleAttr = title && !isCustomDimensionTitle ? ` title="${title}"` : '';
    const srcAttr = ` src="${href}"`;

    return `<img alt="${text}"${srcAttr}${titleAttr}${widthAttr}${heightAttr} loading="lazy">`;
  };

  // parse all RFC3986 URIs
  const urlPattern =
    /\b((([A-Za-z][A-Za-z0-9+.-]*):\/\/([^\/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?)\b/gi;

  const rendererTxtOld = renderer.text;
  renderer.text = (token) => {
    const textWithLinks = token.text.replace(urlPattern, (url) => {
      return `<a href="${url}" target="_blank">${url}</a>`;
    });
    return rendererTxtOld({ ...token, text: textWithLinks });
  };

  const options: MarkedOptions = {
    renderer,
    gfm: true,
    breaks: false,
    pedantic: false,
  };

  // Add preprocessing hook to handle image sizing syntax
  const hooks = new Hooks();
  hooks.preprocess = preprocessMarkdown;
  options.hooks = hooks;

  return options;
};
